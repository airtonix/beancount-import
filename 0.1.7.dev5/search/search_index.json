{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":""},{"location":"#1-install-the-package","title":"1. Install the package","text":"<p>pip <pre><code>pip install mypackage\n</code></pre></p> <p>poetry <pre><code>poetry add mypackage\n</code></pre></p> <p>pdm <pre><code>pdm add mypackage\n</code></pre></p>"},{"location":"#2-create-extractors","title":"2. Create extractors","text":"<p>Base class for CSV extractors</p> <p>Create a file called <code>extractors/csv.py</code> by subclassing <code>ExtractorCsvBase</code>:</p> <pre><code>class MyCsvExtractor(ExtractorCsvBase):\n\n    fields = [\"Date\", \"Description\", \"Amount\", \"Currency\"]\n\n    def process_line(self, lineno, line):\n        return Transaction(\n            date=self.parse_date(line[\"Date\"]),\n            narration=line[\"Description\"],\n            amount=Decimal(line[\"Amount\"]),\n            currency=line[\"Currency\"],\n        )\n</code></pre>"},{"location":"#3-create-import-rules","title":"3. Create import rules","text":"<p>The import configuration file for beancount-importer-rules.</p> <p>Examples</p> import-config.yml<pre><code># yaml-language-server: $schema=https://raw.githubusercontent.com/zenobi-us/beancount-importer-rules/master/schema.json\n\ninputs:\n- match: \"sources/*.csv\" # (1)\n  config:\n    extractor:\n        import_path: \"extractors.my_extractor:YourExtractorClass\" # (2)\n        as_name: \"custom name for this extractor instance\"\n        date_format: \"%Y-%m-%d\"\n        datetime_format: \"%Y-%m-%d %H:%M:%S\"\n    default_file: \"books/{{ date.year }}.bean\" # (3)\n    prepend_postings:\n        - account: \"Assets:Bank\"\n\nimports:\n- name: \"simple\"\n    match:\n      desc: \"Simple Transaction\"\n    actions:\n    - type: \"add_txn\"\n      txn:\n        date: \"2021-01-01\"\n        flag: \"*\"\n        narration: \"Simple Transaction\"\n        postings:\n            - account: \"Expenses:Simple\"\n              amount:\n                number: \"{{ amount }}\"\n                currency: \"USD\"\n</code></pre> <ol> <li>pathname is relative to the workspace root</li> <li>import path is relative to the workspace root</li> <li>pathname is relative to the workspace root</li> </ol> <p>You can view the schema for more details or refer to the ImportDoc api</p>"},{"location":"#4-run-the-importer","title":"4. Run the importer","text":"<p>Import transactions from external sources to Beancount files.</p> <p>Assuming the following directory structure:</p> <pre><code>&gt; tree .\nworkspace/\n    \u251c\u2500\u2500 extractors/\n    \u2502   \u2570\u2500\u2500 my_extractor.py\n    \u2502\n    \u251c\u2500\u2500 sources/\n    \u2502       \u251c\u2500\u2500 2024-01-01.csv\n    \u2502       \u251c\u2500\u2500 2024-01-02.csv\n    \u2502       \u2570\u2500\u2500 2024-01-03.csv\n    \u2502\n    \u251c\u2500\u2500 imported/\n    \u2502   \u251c\u2500\u2500 2024-01-01.bean\n    \u2502   \u251c\u2500\u2500 2024-01-02.bean\n    \u2502   \u2570\u2500\u2500 2024-01-03.bean\n    \u2502\n    \u251c\u2500\u2500 main.bean\n    \u251c\u2500\u2500 options.bean\n    \u251c\u2500\u2500 imported.bean\n    \u251c\u2500\u2500 accounts.bean\n    \u251c\u2500\u2500 data.bean\n    \u2570\u2500\u2500 importer_config.yaml\n</code></pre> <p>The <code>import_cmd</code> command will import matching transactions found in matching files the <code>sources</code> directory to the <code>imported</code> directory.</p> <pre><code>&gt; beancount-import import \\\n    -w workspace \\\n    -b data.bean \\\n    -c importer_config.yaml\n</code></pre> Note <p>We recommend having separate beanfiles for options and data.</p> <ul> <li><code>main.bean</code><ul> <li><code>data.bean</code><ul> <li><code>accounts.bean</code></li> <li><code>imported.bean</code></li> </ul> </li> <li><code>options.bean</code></li> </ul> </li> </ul> <p>Your <code>main.bean</code> should import <code>data.bean</code>, <code>options.bean</code>.</p> <p>Your <code>data.bean</code> should import <code>accounts.bean</code>, <code>imported.bean</code>.</p> <p>This way, you can keep your data and options separate from your main beanfile.</p> <p>But more importantly, we recommend this because beancount-importer-rules doesn't understand some of the syntax used for options.</p>"},{"location":"#read-more","title":"Read More","text":"<ul> <li>Configuration</li> <li>API Reference</li> </ul>"},{"location":"api/","title":"Api","text":""},{"location":"api/#data-types","title":"Data Types","text":"<p>The following data types are used to define the configuration of the importer.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleFileMatch","title":"<code>SimpleFileMatch = str | StrExactMatch | StrRegexMatch</code>  <code>module-attribute</code>","text":"<p>Currently, we support three different modes of matching a CSV file. The first one is the default one, glob. A simple string would make it use glob mode like this:</p> <pre><code>inputs:\n  - match: \"import-data/mercury/*.csv\"\n</code></pre> <p>You can also do an exact match like this:</p> <pre><code>inputs:\n- match:\n    equals: \"import-data/mercury/2024.csv\"\n</code></pre> <p>Or, if you prefer regular expression:</p> <pre><code>inputs:\n- match:\n    regex: \"import-data/mercury/2([0-9]+).csv\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.ActionAddTxn","title":"<code>ActionAddTxn</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>Add a transaction to the beancount file.</p> <p>This is the default action type. If your action does not specify a type, it will be assumed to be an add transaction action.</p> <p>The following keys are available for the add transaction action:</p> <ul> <li><code>file</code>: output beancount file name to write the transaction to</li> <li><code>txn</code>: the template of the transaction to insert</li> </ul> <p>A transaction template is an object that contains the following keys:</p> <ul> <li><code>id</code>: the optional <code>import-id</code> to overwrite the default one. By default, <code>{{ file | as_posix_path }}:{{ lineno }}</code> will be used unless the extractor provides a default value.</li> <li><code>date</code>: the optional date value to overwrite the default one. By default, <code>{{ date }}</code> will be used.</li> <li><code>flag</code>: the optional flag value to overwrite the default one. By default, <code>*</code> will be used.</li> <li><code>narration</code>: the optional narration value to overwrite the default one. By default <code>{{ desc | default(bank_desc, true) }}</code> will be used.</li> <li><code>payee</code>: the optional payee value of the transaction.</li> <li><code>tags</code>: an optional list of tags for the transaction</li> <li><code>links</code>: an optional list of links for the transaction</li> <li><code>metadata</code>: an optional list of <code>name</code> and <code>value</code> objects as the metadata items for the transaction.</li> <li><code>postings</code>: a list of templates for postings in the transaction.</li> </ul> <p>The structure of the posting template object looks like this.</p> <ul> <li><code>account</code>: the account of posting</li> <li><code>amount</code>: the optional amount object with <code>number</code> and <code>currency</code> keys</li> <li><code>price</code>: the optional amount object with <code>number</code> and <code>currency</code> keys</li> <li><code>cost</code>: the optional template of cost spec</li> </ul>"},{"location":"api/#beancount_importer_rules.data_types.ActionAddTxn.file","title":"<code>file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Which file to add the transaction to. If not provided, the default file will be used.</p>"},{"location":"api/#beancount_importer_rules.data_types.ActionAddTxn.txn","title":"<code>txn: TransactionTemplate</code>  <code>instance-attribute</code>","text":"<p>The transaction transform template</p>"},{"location":"api/#beancount_importer_rules.data_types.ActionAddTxn.type","title":"<code>type: typing.Literal[ActionType.add_txn] = pydantic.Field(ActionType.add_txn)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>indicates that this action is to add a transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.ActionDelTxn","title":"<code>ActionDelTxn</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>Delete a transaction from the beancount file.</p> <p>The following keys are available for the delete transaction action:</p> <ul> <li><code>txn</code>: the template of the transaction to insert</li> </ul> <p>A deleting transaction template is an object that contains the following keys:</p> <ul> <li><code>id</code>: the <code>import-id</code> value for ensuring transactions to be deleted. By default, <code>{{ file | as_posix_path }}:{{ lineno }}</code> will be used unless the extractor provides a default value.</li> </ul>"},{"location":"api/#beancount_importer_rules.data_types.ActionDelTxn.txn","title":"<code>txn: DeleteTransactionTemplate</code>  <code>instance-attribute</code>","text":"<p>The transaction to delete</p>"},{"location":"api/#beancount_importer_rules.data_types.ActionDelTxn.type","title":"<code>type: typing.Literal[ActionType.del_txn] = pydantic.Field(ActionType.del_txn)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>indicates that this action is to delete a transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.ActionIgnore","title":"<code>ActionIgnore</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>Ignore the transaction.</p> <p>This prevents the transaction from being added to the beancount file.</p> <p>Sometimes, we are not interested in some transactions, but if we don't process them, you will still see them appear in the \"unprocessed transactions\" section of the report provided by our command line tool. To mark one transaction as processed, you can simply use the <code>ignore</code> action like this:</p> <pre><code>- name: Ignore unused entries\n  match:\n    extractor:\n      equals: \"mercury\"\n    desc:\n      one_of:\n        - Mercury Credit\n        - Mercury Checking xx1234\n  actions:\n    - type: ignore\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.ActionIgnore.type","title":"<code>type: typing.Literal[ActionType.ignore] = pydantic.Field(ActionType.ignore)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>indicates that this action is to ignore the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.Amount","title":"<code>Amount</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>A posting amount transform template.</p> <p>Used to transform the raw transaction amount into a beancount posting amount.</p> <p>Examples</p> <pre><code>amount:\n    number: \"{{ amount }}\"\n    currency: \"USD\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.Amount.currency","title":"<code>currency: str</code>  <code>instance-attribute</code>","text":"<p>The currency of the amount.</p>"},{"location":"api/#beancount_importer_rules.data_types.Amount.number","title":"<code>number: str</code>  <code>instance-attribute</code>","text":"<p>The amount number. It can be a Jinja2 template.</p>"},{"location":"api/#beancount_importer_rules.data_types.BeancountTransaction","title":"<code>BeancountTransaction</code>  <code>dataclass</code>","text":"<p>Beancount transaction.</p>"},{"location":"api/#beancount_importer_rules.data_types.BeancountTransaction.file","title":"<code>file: pathlib.Path</code>  <code>instance-attribute</code>","text":"<p>The beancount file path</p>"},{"location":"api/#beancount_importer_rules.data_types.BeancountTransaction.id","title":"<code>id: str</code>  <code>instance-attribute</code>","text":"<p>The import id of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.BeancountTransaction.lineno","title":"<code>lineno: int</code>  <code>instance-attribute</code>","text":"<p>The line number of the transaction in the beancount file</p>"},{"location":"api/#beancount_importer_rules.data_types.ChangeSet","title":"<code>ChangeSet</code>  <code>dataclass</code>","text":"<p>Change set for beancount transactions.</p> <p>It represents the changes to be made to the beancount file.</p>"},{"location":"api/#beancount_importer_rules.data_types.ChangeSet.add","title":"<code>add: list[GeneratedTransaction]</code>  <code>instance-attribute</code>","text":"<p>list of generated transaction to add</p>"},{"location":"api/#beancount_importer_rules.data_types.ChangeSet.dangling","title":"<code>dangling: list[BeancountTransaction] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>list of existing beancount transaction with no corresponding generated transactions (dangling)</p>"},{"location":"api/#beancount_importer_rules.data_types.ChangeSet.remove","title":"<code>remove: list[BeancountTransaction]</code>  <code>instance-attribute</code>","text":"<p>list of existing beancount transaction to remove</p>"},{"location":"api/#beancount_importer_rules.data_types.ChangeSet.update","title":"<code>update: dict[int, GeneratedTransaction]</code>  <code>instance-attribute</code>","text":"<p>map from</p>"},{"location":"api/#beancount_importer_rules.data_types.DateAfterMatch","title":"<code>DateAfterMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values after a date, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_after: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.DateAfterMatch.date_after","title":"<code>date_after: str</code>  <code>instance-attribute</code>","text":"<p>The date to match after</p>"},{"location":"api/#beancount_importer_rules.data_types.DateAfterMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"api/#beancount_importer_rules.data_types.DateBeforeMatch","title":"<code>DateBeforeMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values before a date, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_before: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.DateBeforeMatch.date_before","title":"<code>date_before: str</code>  <code>instance-attribute</code>","text":"<p>The date to match before</p>"},{"location":"api/#beancount_importer_rules.data_types.DateBeforeMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"api/#beancount_importer_rules.data_types.DateBetweenMatch","title":"<code>DateBetweenMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values between two dates, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_before: \"2021-01-01\"\n      date_after: \"2020-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.DateBetweenMatch.date_after","title":"<code>date_after: str</code>  <code>instance-attribute</code>","text":"<p>The date to match after</p>"},{"location":"api/#beancount_importer_rules.data_types.DateBetweenMatch.date_before","title":"<code>date_before: str</code>  <code>instance-attribute</code>","text":"<p>The date to match before</p>"},{"location":"api/#beancount_importer_rules.data_types.DateBetweenMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"api/#beancount_importer_rules.data_types.DateSameDayMatch","title":"<code>DateSameDayMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values with the same day, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_same_day: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.DateSameDayMatch.date_same_day","title":"<code>date_same_day: str</code>  <code>instance-attribute</code>","text":"<p>The date to match on the day</p>"},{"location":"api/#beancount_importer_rules.data_types.DateSameDayMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"api/#beancount_importer_rules.data_types.DateSameMonthMatch","title":"<code>DateSameMonthMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values with the same month, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_same_month: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.DateSameMonthMatch.date_same_month","title":"<code>date_same_month: str</code>  <code>instance-attribute</code>","text":"<p>The date to match on the month</p>"},{"location":"api/#beancount_importer_rules.data_types.DateSameMonthMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"api/#beancount_importer_rules.data_types.DateSameYearMatch","title":"<code>DateSameYearMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values with the same year, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_same_year: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.DateSameYearMatch.date_same_year","title":"<code>date_same_year: str</code>  <code>instance-attribute</code>","text":"<p>The date to match on the year</p>"},{"location":"api/#beancount_importer_rules.data_types.DateSameYearMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"api/#beancount_importer_rules.data_types.DeleteTransactionTemplate","title":"<code>DeleteTransactionTemplate</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>A transaction delete template.</p>"},{"location":"api/#beancount_importer_rules.data_types.DeleteTransactionTemplate.id","title":"<code>id: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the import-id for deleting</p>"},{"location":"api/#beancount_importer_rules.data_types.DeletedTransaction","title":"<code>DeletedTransaction</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>represents a deleted transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportDoc","title":"<code>ImportDoc</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>The import configuration file for beancount-importer-rules.</p> <p>Examples</p> import-config.yml<pre><code># yaml-language-server: $schema=https://raw.githubusercontent.com/zenobi-us/beancount-importer-rules/master/schema.json\n\ninputs:\n- match: \"sources/*.csv\" # (1)\n  config:\n    extractor:\n        import_path: \"extractors.my_extractor:YourExtractorClass\" # (2)\n        as_name: \"custom name for this extractor instance\"\n        date_format: \"%Y-%m-%d\"\n        datetime_format: \"%Y-%m-%d %H:%M:%S\"\n    default_file: \"books/{{ date.year }}.bean\" # (3)\n    prepend_postings:\n        - account: \"Assets:Bank\"\n\nimports:\n- name: \"simple\"\n    match:\n      desc: \"Simple Transaction\"\n    actions:\n    - type: \"add_txn\"\n      txn:\n        date: \"2021-01-01\"\n        flag: \"*\"\n        narration: \"Simple Transaction\"\n        postings:\n            - account: \"Expenses:Simple\"\n              amount:\n                number: \"{{ amount }}\"\n                currency: \"USD\"\n</code></pre> <ol> <li>pathname is relative to the workspace root</li> <li>import path is relative to the workspace root</li> <li>pathname is relative to the workspace root</li> </ol> <p>You can view the schema for more details or refer to the ImportDoc api</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportDoc.context","title":"<code>context: dict | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Context comes in handy when you need to define variables to be referenced in the template. As you can see in the example, we define a <code>routine_expenses</code> dictionary variable in the context.</p> <pre><code>context:\n  routine_expenses:\n    \"Amazon Web Services\":\n      account: Expenses:Engineering:Servers:AWS\n    Netlify:\n      account: Expenses:Engineering:ServiceSubscription\n    Mailchimp:\n      account: Expenses:Marketing:ServiceSubscription\n    Circleci:\n      account: Expenses:Engineering:ServiceSubscription\n    Adobe:\n      account: Expenses:Design:ServiceSubscription\n    \"Digital Ocean\":\n      account: Expenses:Engineering:ServiceSubscription\n    Microsoft:\n      account: Expenses:Office:Supplies:SoftwareAsService\n      narration: \"Microsoft 365 Apps for Business Subscription\"\n    \"Mercury IO Cashback\":\n      account: Expenses:CreditCardCashback\n      narration: \"Mercury IO Cashback\"\n    WeWork:\n      account: Expenses:Office\n      narration: \"Virtual mailing address service fee from WeWork\"\n</code></pre> <p>Then, in the transaction template, we look up the dictionary to find out what narration value to use:</p> <pre><code>\"{{ routine_expenses[desc].narration | default(desc, true) | default(bank_desc, true) }}\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.ImportDoc.imports","title":"<code>imports: ImportList</code>  <code>instance-attribute</code>","text":"<p>The import rules</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportDoc.inputs","title":"<code>inputs: list[InputConfig]</code>  <code>instance-attribute</code>","text":"<p>The input rules</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportDoc.outputs","title":"<code>outputs: list[OutputConfig] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The output configuration</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportList","title":"<code>ImportList</code>","text":"<p>               Bases: <code>RootModel[List[ImportRule | IncludeRule]]</code></p> <p>The list of import rules.</p> <p>Can be a list of ImportRule or IncludeRule</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportRule","title":"<code>ImportRule</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>An import rule to match and process transactions.</p> <p>The following keys are available for the import configuration:</p> <ul> <li><code>name</code>: An optional name for the user to comment on this matching rule. Currently, it has no functional purpose.</li> <li><code>match</code>: The rule for matching raw transactions extracted from the input CSV files. As described in the Import Match Rule Definition</li> <li><code>actions</code>: Decide what to do with the matched raw transactions, as the Import Action Definition describes.</li> </ul>"},{"location":"api/#beancount_importer_rules.data_types.ImportRule.actions","title":"<code>actions: list[Action]</code>  <code>instance-attribute</code>","text":"<p>The actions to perform</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportRule.common_cond","title":"<code>common_cond: TxnMatchRule | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>common condition to meet on top of the match rules</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportRule.match","title":"<code>match: TxnMatchRule | list[TxnMatchVars]</code>  <code>instance-attribute</code>","text":"<p>The match rule</p>"},{"location":"api/#beancount_importer_rules.data_types.ImportRule.name","title":"<code>name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of import rule, Not used, just for reference</p>"},{"location":"api/#beancount_importer_rules.data_types.IncludeRule","title":"<code>IncludeRule</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>Include other yaml files that contain lists of ImportRule</p>"},{"location":"api/#beancount_importer_rules.data_types.IncludeRule.include","title":"<code>include: str | list[str]</code>  <code>instance-attribute</code>","text":"<p>The file path(s) to include</p>"},{"location":"api/#beancount_importer_rules.data_types.InputConfig","title":"<code>InputConfig</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>The input configuration for the import rule.</p>"},{"location":"api/#beancount_importer_rules.data_types.InputConfigDetails","title":"<code>InputConfigDetails</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>The input configuration details for the import rule.</p>"},{"location":"api/#beancount_importer_rules.data_types.InputConfigDetails.append_postings","title":"<code>append_postings: list[PostingTemplate] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Postings are to be appended to the generated transactions from the matched file.                     A list of posting templates as described in the Add Transaction Action section.</p>"},{"location":"api/#beancount_importer_rules.data_types.InputConfigDetails.default_file","title":"<code>default_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The default output file for generated transactions from the matched file to use if not specified                 in the <code>add_txn</code> action.</p>"},{"location":"api/#beancount_importer_rules.data_types.InputConfigDetails.default_txn","title":"<code>default_txn: TransactionTemplate | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The default transaction template values to use in the generated transactions from the                 matched file. Please see the Add Transaction Action section.</p>"},{"location":"api/#beancount_importer_rules.data_types.InputConfigDetails.extractor","title":"<code>extractor: ExractorInputConfig</code>  <code>instance-attribute</code>","text":"<p>A python import path to the extractor to use for extracting transactions from the matched file.             The format is <code>package.module:extractor_class</code>. For example, <code>beancount_import_rules.extractors.plaid:PlaidExtractor</code>.             Your Extractor Class should inherit from <code>beancount_import_rules.extractors.ExtractorBase</code> or             <code>beancount_import_rules.extractors.ExtractorCsvBase</code>.</p>"},{"location":"api/#beancount_importer_rules.data_types.InputConfigDetails.prepend_postings","title":"<code>prepend_postings: list[PostingTemplate] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Postings are to be prepended for the generated transactions from the matched file. A                 list of posting templates as described in the Add Transaction Action section.</p>"},{"location":"api/#beancount_importer_rules.data_types.MetadataItemTemplate","title":"<code>MetadataItemTemplate</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>A metadata list item template.</p> <pre><code>txn:\n    metadata:\n        - name: \"import-id\"\n          value: \"123456\"\n        - name: \"import-src\"\n          value: \"plaid\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.MetadataItemTemplate.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>the name of the metadata</p>"},{"location":"api/#beancount_importer_rules.data_types.MetadataItemTemplate.value","title":"<code>value: str | bool | int | None</code>  <code>instance-attribute</code>","text":"<p>the value of the metadata</p>"},{"location":"api/#beancount_importer_rules.data_types.PostingTemplate","title":"<code>PostingTemplate</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>A posting transform template.</p> <p>Used to transform the raw transaction into a beancount posting.</p> <pre><code>txn:\n    postings:\n        - account: \"Expenses:Simple\"\n          amount:\n              number: \"{{ amount }}\"\n              currency: \"USD\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.PostingTemplate.account","title":"<code>account: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The account of the posting.</p>"},{"location":"api/#beancount_importer_rules.data_types.PostingTemplate.amount","title":"<code>amount: AmountTemplate | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of the posting.</p>"},{"location":"api/#beancount_importer_rules.data_types.PostingTemplate.cost","title":"<code>cost: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cost of the posting.</p>"},{"location":"api/#beancount_importer_rules.data_types.PostingTemplate.price","title":"<code>price: AmountTemplate | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The price of the posting.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule","title":"<code>SimpleTxnMatchRule</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>The raw transactions extracted by the extractor come with many attributes. Here we list only a few from it:</p> <p>The <code>match</code> object should be a dictionary.</p> <p>The key is the transaction attribute to match, and the value is the regular expression of the target pattern to match.</p> <p>All listed attributes need to match so that a transaction will considered matched.</p> <p>Only simple matching logic is possible with the current approach.</p> <p>We will extend the matching rule to support more complex matching logic in the future, such as NOT, AND, OR operators.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.bank_desc","title":"<code>bank_desc: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The bank description of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.category","title":"<code>category: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The category of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.currency","title":"<code>currency: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The currency of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.date","title":"<code>date: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The date of the transaction to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    date: \"2021-01-01\"\n</code></pre> <pre><code>imports:\n- match:\n    date:\n        before: \"2021-01-01\"\n        format: \"%Y-%m-%d\"\n</code></pre> <pre><code>imports:\n- match:\n    date:\n        after: \"2021-01-01\"\n        format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.desc","title":"<code>desc: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The description of the transaction to match.</p> <p>Probably the most common field to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    desc: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        prefix: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        suffix: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        contains: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        one_of:\n            - DoorDash\n            - UberEats\n            - Postmate\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.dest_account","title":"<code>dest_account: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The destination account of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.extractor","title":"<code>extractor: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The extractor to match. This will be produced by the Extractor.get_name() method.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.file","title":"<code>file: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The file to match. This will be the file path of the source file.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    file: \"data/transactions.csv\"\n</code></pre> <pre><code>imports:\n- match:\n    file:\n        prefix: \"data/\"\n</code></pre> <pre><code>imports:\n- match:\n    file:\n        suffix: \".csv\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.gl_code","title":"<code>gl_code: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The general ledger code of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.last_four_digits","title":"<code>last_four_digits: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last four digits of the card of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.name_on_card","title":"<code>name_on_card: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The name on the card of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.note","title":"<code>note: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The note of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.payee","title":"<code>payee: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The payee of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.post_date","title":"<code>post_date: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The post date of the transaction to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    post_date: \"2021-01-01\"\n</code></pre> <pre><code>imports:\n- match:\n    post_date:\n        before: \"2021-01-01\"\n        format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.reference","title":"<code>reference: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The reference of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.source_account","title":"<code>source_account: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The source account of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.status","title":"<code>status: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The status of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.subcategory","title":"<code>subcategory: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The subcategory of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.timezone","title":"<code>timezone: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The timezone of the transaction to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    timezone: \"America/Los_Angeles\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.transaction_id","title":"<code>transaction_id: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The transaction id of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.SimpleTxnMatchRule.type","title":"<code>type: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of the transaction to match.</p>"},{"location":"api/#beancount_importer_rules.data_types.StrContainsMatch","title":"<code>StrContainsMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values containing a string, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      contains: \"DoorDash\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.StrContainsMatch.contains","title":"<code>contains: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field contain the string</p>"},{"location":"api/#beancount_importer_rules.data_types.StrExactMatch","title":"<code>StrExactMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match an exact value, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      equals: \"DoorDash\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.StrExactMatch.equals","title":"<code>equals: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field equal the value</p>"},{"location":"api/#beancount_importer_rules.data_types.StrOneOfMatch","title":"<code>StrOneOfMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values belonging to a list of values, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      one_of:\n        - DoorDash\n        - UberEats\n        - Postmate\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.StrOneOfMatch.one_of","title":"<code>one_of: list[str]</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field match one of the values</p>"},{"location":"api/#beancount_importer_rules.data_types.StrPrefixMatch","title":"<code>StrPrefixMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values with a prefix, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      prefix: \"DoorDash\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.StrPrefixMatch.prefix","title":"<code>prefix: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field start with the string</p>"},{"location":"api/#beancount_importer_rules.data_types.StrRegexMatch","title":"<code>StrRegexMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>When a simple string value is provided, regular expression matching will be used.</p> <p>it uses re.search. so if you want to match the whole string, you need to use <code>^</code> and <code>$</code> in the regex.</p> <p><pre><code>imports:\n- match:\n    desc: \"^DoorDash (.+)\"\n</code></pre> or <pre><code>imports:\n- match:\n    desc:\n      regex: \"^DoorDash (.+)\"\n</code></pre></p>"},{"location":"api/#beancount_importer_rules.data_types.StrRegexMatch.regex","title":"<code>regex: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field match the regular expression</p>"},{"location":"api/#beancount_importer_rules.data_types.StrSuffixMatch","title":"<code>StrSuffixMatch</code>","text":"<p>               Bases: <code>MatchBaseModel</code></p> <p>To match values with a suffix, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      suffix: \"DoorDash\"\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.StrSuffixMatch.suffix","title":"<code>suffix: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field end with the string</p>"},{"location":"api/#beancount_importer_rules.data_types.Transaction","title":"<code>Transaction</code>  <code>dataclass</code>","text":"<p>A transaction object.</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate","title":"<code>TransactionTemplate</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>A transaction transform template.</p> <p>Used to transform the raw transaction into a beancount transaction.</p> <pre><code>txn:\n    date: \"2021-01-01\"\n    flag: \"*\"\n    narration: \"Simple Transaction\"\n    metadata:\n        - name: \"icon\"\n          value: \"\ud83c\udf54\"\n    postings:\n        - account: \"Expenses:Simple\"\n          amount:\n              number: \"{{ amount }}\"\n              currency: \"USD\"\n</code></pre> <p>results in the following beancount transaction:</p> <pre><code>2021-01-01 * \"Simple Transaction\"\n    icon: \ud83c\udf54\n    Expenses:Simple                            100 USD\n</code></pre>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.date","title":"<code>date: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the date of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.flag","title":"<code>flag: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the flag of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.id","title":"<code>id: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the import-id for de-duplication</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.links","title":"<code>links: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the links of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.metadata","title":"<code>metadata: list[MetadataItemTemplate] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the metadata of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.narration","title":"<code>narration: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the narration of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.payee","title":"<code>payee: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the payee of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.postings","title":"<code>postings: list[PostingTemplate] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the postings of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TransactionTemplate.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the tags of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.TxnMatchVars","title":"<code>TxnMatchVars</code>","text":"<p>               Bases: <code>ImportBaseModel</code></p> <p>From time to time, you may find yourself writing similar import-matching rules with similar transaction templates. To avoid repeating yourself, you can also write multiple match conditions with their corresponding variables to be used by the template in the same import statement. For example, you can simply do the following two import statements:</p> <pre><code>imports:\n- name: PG&amp;E Gas\n    match:\n    extractor:\n      equals: \"plaid\"\n    desc:\n      prefix: \"PGANDE WEB ONLINE \"\n    actions:\n    - txn:\n        payee: \"{{ payee }}\"\n        narration: \"Paid American Express Blue Cash Everyday\"\n        postings:\n        - account: \"Expenses:Util:Gas:PGE\"\n          amount:\n            number: \"{{ -amount }}\"\n            currency: \"{{ currency | default('USD', true) }}\"\n\n- name: Comcast\n  match:\n    extractor:\n      equals: \"plaid\"\n    desc: \"Comcast\"\n  actions:\n  - txn:\n      payee: \"{{ payee }}\"\n      narration: \"Comcast\"\n      postings:\n      - account: \"Expenses:Util:Internet:Comcast\"\n        amount:\n          number: \"{{ -amount }}\"\n          currency: \"{{ currency | default('USD', true) }}\"\n</code></pre> <p>With match and variables, you can write:</p> <pre><code>imports:\n- name: Household expenses\n  common_cond:\n    extractor:\n      equals: \"plaid\"\n  match:\n  - cond:\n      desc:\n          prefix: \"PGANDE WEB ONLINE \"\n      vars:\n      account: \"Expenses:Util:Gas:PGE\"\n      narration: \"Paid American Express Blue Cash Everyday\"\n  - cond:\n      desc: \"Comcast\"\n      vars:\n      account: \"Expenses:Housing:Util:Internet:Comcast\"\n      narration: \"Comcast\"\n  actions:\n  - txn:\n      payee: \"{{ payee }}\"\n      narration: \"{{ narration }}\"\n      postings:\n      - account: \"{{ account } \"\n          amount:\n            number: \"{{ -amount }}\"\n            currency: \"{{ currency | default('USD', true) }}\"\n</code></pre> <p>The <code>common_cond</code> is the condition to meet for all the matches. Instead of a map, you define the match with the <code>cond</code> field and the corresponding variables with the <code>vars</code> field. Please note that the <code>vars</code> can also be the Jinja2 template and will rendered before feeding into the transaction template. If there are any original variables from the transaction with the same name defined in the <code>vars</code> field, the variables from the <code>vars</code> field always override.</p>"},{"location":"api/#beancount_importer_rules.data_types.UnprocessedTransaction","title":"<code>UnprocessedTransaction</code>  <code>dataclass</code>","text":"<p>Unprocessed transaction.</p> <p>It represents the transaction extracted from the source file.</p>"},{"location":"api/#beancount_importer_rules.data_types.UnprocessedTransaction.appending_postings","title":"<code>appending_postings: list[GeneratedPosting] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The generated postings to append to the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.UnprocessedTransaction.import_id","title":"<code>import_id: str</code>  <code>instance-attribute</code>","text":"<p>The import id of the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.UnprocessedTransaction.output_file","title":"<code>output_file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The generated output filename if available</p>"},{"location":"api/#beancount_importer_rules.data_types.UnprocessedTransaction.prepending_postings","title":"<code>prepending_postings: list[GeneratedPosting] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The generated postings to prepend to the transaction</p>"},{"location":"api/#beancount_importer_rules.data_types.UnprocessedTransaction.txn","title":"<code>txn: Transaction</code>  <code>instance-attribute</code>","text":"<p>The unprocessed transaction</p>"},{"location":"api/#extractors","title":"Extractors","text":"<p>These provide the ability to extract data from various sources.</p> <p>So far there is a convenience base class for CSV files.</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorBase","title":"<code>ExtractorBase</code>","text":"<p>Base class for extractors</p> <p>Examples</p> <pre><code>class MyExtractor(ExtractorBase):\n    def detect(self):\n        return True\n\n    def process(self):\n        yield Transaction(\n            date=datetime.date.today(),\n            narration=\"Test transaction\",\n            amount=Decimal(\"10.00\"),\n            currency=\"USD\",\n        )\n</code></pre>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase","title":"<code>ExtractorCsvBase</code>","text":"<p>               Bases: <code>ExtractorBase</code></p> <p>Base class for CSV extractors</p> <p>Create a file called <code>extractors/csv.py</code> by subclassing <code>ExtractorCsvBase</code>:</p> <pre><code>class MyCsvExtractor(ExtractorCsvBase):\n\n    fields = [\"Date\", \"Description\", \"Amount\", \"Currency\"]\n\n    def process_line(self, lineno, line):\n        return Transaction(\n            date=self.parse_date(line[\"Date\"]),\n            narration=line[\"Description\"],\n            amount=Decimal(line[\"Amount\"]),\n            currency=line[\"Currency\"],\n        )\n</code></pre>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.delimiter","title":"<code>delimiter: str = ','</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The delimiter used in the CSV file</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.fields","title":"<code>fields: typing.List[str]</code>  <code>instance-attribute</code>","text":"<p>The fields in the CSV file</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.detect","title":"<code>detect(file_path)</code>","text":"<p>Check if the input file is a CSV file with the expected fields. Should this extractor be used to process the file?</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.detect_has_header","title":"<code>detect_has_header(file_path)</code>","text":"<p>Check if the supplied csv file has a header row.</p> <p>It will if the fieldnames attribute is not None and they match the values of the first row of the file.</p> <p>We do this to detect if we need to skip the first row; it seems that the DictReader class does not automatically detect if the file has a header row or not and will return the first row as data if the fieldnames attribute is not set.</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.fingerprint","title":"<code>fingerprint(file_path)</code>","text":"<p>Generate a fingerprint for the CSV file</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.get_linecount","title":"<code>get_linecount(file_path)</code>","text":"<p>Get the number of lines in a file</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.parse_date","title":"<code>parse_date(date_str)</code>","text":"<p>Parse a date string using the self.format</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.parse_datetime","title":"<code>parse_datetime(date_str)</code>","text":"<p>Parse a date string using the self.format</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.process","title":"<code>process(file_path)</code>","text":"<p>Process the CSV file and yield transactions.</p> <p>Loops over the rows in the CSV file and yields a transaction for each row by calling <code>process_line</code>.</p>"},{"location":"api/#beancount_importer_rules.extractor.ExtractorCsvBase.process_line","title":"<code>process_line(lineno, line, file_path, line_count)</code>","text":"<p>Process a line in the CSV file and return a transaction.</p> <p>This method should be implemented by subclasses to return a <code>Transaction</code>.</p>"},{"location":"api/#beancount_importer_rules.extractor.create_extractor_factory","title":"<code>create_extractor_factory(class_name=None, working_dir=Path.cwd())</code>","text":"<p>Manages importing the defined extractor module and returning the extractor</p>"},{"location":"configuration/","title":"Configuration","text":"<p>The configuration file is a YAML file that contains the configuration of the importer. The configuration file is used to define the rules that the importer will use to process the data. The configuration file is divided into several sections, each of which defines a different aspect of the importer's behavior.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportDoc","title":"<code>ImportDoc</code>","text":"<p>The import configuration file for beancount-importer-rules.</p> <p>Examples</p> import-config.yml<pre><code># yaml-language-server: $schema=https://raw.githubusercontent.com/zenobi-us/beancount-importer-rules/master/schema.json\n\ninputs:\n- match: \"sources/*.csv\" # (1)\n  config:\n    extractor:\n        import_path: \"extractors.my_extractor:YourExtractorClass\" # (2)\n        as_name: \"custom name for this extractor instance\"\n        date_format: \"%Y-%m-%d\"\n        datetime_format: \"%Y-%m-%d %H:%M:%S\"\n    default_file: \"books/{{ date.year }}.bean\" # (3)\n    prepend_postings:\n        - account: \"Assets:Bank\"\n\nimports:\n- name: \"simple\"\n    match:\n      desc: \"Simple Transaction\"\n    actions:\n    - type: \"add_txn\"\n      txn:\n        date: \"2021-01-01\"\n        flag: \"*\"\n        narration: \"Simple Transaction\"\n        postings:\n            - account: \"Expenses:Simple\"\n              amount:\n                number: \"{{ amount }}\"\n                currency: \"USD\"\n</code></pre> <ol> <li>pathname is relative to the workspace root</li> <li>import path is relative to the workspace root</li> <li>pathname is relative to the workspace root</li> </ol> <p>You can view the schema for more details or refer to the ImportDoc api</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportDoc.context","title":"<code>context: dict | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Context comes in handy when you need to define variables to be referenced in the template. As you can see in the example, we define a <code>routine_expenses</code> dictionary variable in the context.</p> <pre><code>context:\n  routine_expenses:\n    \"Amazon Web Services\":\n      account: Expenses:Engineering:Servers:AWS\n    Netlify:\n      account: Expenses:Engineering:ServiceSubscription\n    Mailchimp:\n      account: Expenses:Marketing:ServiceSubscription\n    Circleci:\n      account: Expenses:Engineering:ServiceSubscription\n    Adobe:\n      account: Expenses:Design:ServiceSubscription\n    \"Digital Ocean\":\n      account: Expenses:Engineering:ServiceSubscription\n    Microsoft:\n      account: Expenses:Office:Supplies:SoftwareAsService\n      narration: \"Microsoft 365 Apps for Business Subscription\"\n    \"Mercury IO Cashback\":\n      account: Expenses:CreditCardCashback\n      narration: \"Mercury IO Cashback\"\n    WeWork:\n      account: Expenses:Office\n      narration: \"Virtual mailing address service fee from WeWork\"\n</code></pre> <p>Then, in the transaction template, we look up the dictionary to find out what narration value to use:</p> <pre><code>\"{{ routine_expenses[desc].narration | default(desc, true) | default(bank_desc, true) }}\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportDoc.imports","title":"<code>imports: ImportList</code>  <code>instance-attribute</code>","text":"<p>The import rules</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportDoc.inputs","title":"<code>inputs: list[InputConfig]</code>  <code>instance-attribute</code>","text":"<p>The input rules</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportDoc.outputs","title":"<code>outputs: list[OutputConfig] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The output configuration</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportList","title":"<code>ImportList</code>","text":"<p>The list of import rules.</p> <p>Can be a list of ImportRule or IncludeRule</p>"},{"location":"configuration/#beancount_importer_rules.data_types.IncludeRule","title":"<code>IncludeRule</code>","text":"<p>Include other yaml files that contain lists of ImportRule</p>"},{"location":"configuration/#beancount_importer_rules.data_types.IncludeRule.include","title":"<code>include: str | list[str]</code>  <code>instance-attribute</code>","text":"<p>The file path(s) to include</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportRule","title":"<code>ImportRule</code>","text":"<p>An import rule to match and process transactions.</p> <p>The following keys are available for the import configuration:</p> <ul> <li><code>name</code>: An optional name for the user to comment on this matching rule. Currently, it has no functional purpose.</li> <li><code>match</code>: The rule for matching raw transactions extracted from the input CSV files. As described in the Import Match Rule Definition</li> <li><code>actions</code>: Decide what to do with the matched raw transactions, as the Import Action Definition describes.</li> </ul>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportRule.actions","title":"<code>actions: list[Action]</code>  <code>instance-attribute</code>","text":"<p>The actions to perform</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportRule.common_cond","title":"<code>common_cond: TxnMatchRule | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>common condition to meet on top of the match rules</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportRule.match","title":"<code>match: TxnMatchRule | list[TxnMatchVars]</code>  <code>instance-attribute</code>","text":"<p>The match rule</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ImportRule.name","title":"<code>name: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Name of import rule, Not used, just for reference</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionAddTxn","title":"<code>ActionAddTxn</code>","text":"<p>Add a transaction to the beancount file.</p> <p>This is the default action type. If your action does not specify a type, it will be assumed to be an add transaction action.</p> <p>The following keys are available for the add transaction action:</p> <ul> <li><code>file</code>: output beancount file name to write the transaction to</li> <li><code>txn</code>: the template of the transaction to insert</li> </ul> <p>A transaction template is an object that contains the following keys:</p> <ul> <li><code>id</code>: the optional <code>import-id</code> to overwrite the default one. By default, <code>{{ file | as_posix_path }}:{{ lineno }}</code> will be used unless the extractor provides a default value.</li> <li><code>date</code>: the optional date value to overwrite the default one. By default, <code>{{ date }}</code> will be used.</li> <li><code>flag</code>: the optional flag value to overwrite the default one. By default, <code>*</code> will be used.</li> <li><code>narration</code>: the optional narration value to overwrite the default one. By default <code>{{ desc | default(bank_desc, true) }}</code> will be used.</li> <li><code>payee</code>: the optional payee value of the transaction.</li> <li><code>tags</code>: an optional list of tags for the transaction</li> <li><code>links</code>: an optional list of links for the transaction</li> <li><code>metadata</code>: an optional list of <code>name</code> and <code>value</code> objects as the metadata items for the transaction.</li> <li><code>postings</code>: a list of templates for postings in the transaction.</li> </ul> <p>The structure of the posting template object looks like this.</p> <ul> <li><code>account</code>: the account of posting</li> <li><code>amount</code>: the optional amount object with <code>number</code> and <code>currency</code> keys</li> <li><code>price</code>: the optional amount object with <code>number</code> and <code>currency</code> keys</li> <li><code>cost</code>: the optional template of cost spec</li> </ul>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionAddTxn.file","title":"<code>file: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Which file to add the transaction to. If not provided, the default file will be used.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionAddTxn.txn","title":"<code>txn: TransactionTemplate</code>  <code>instance-attribute</code>","text":"<p>The transaction transform template</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionAddTxn.type","title":"<code>type: typing.Literal[ActionType.add_txn] = pydantic.Field(ActionType.add_txn)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>indicates that this action is to add a transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionDelTxn","title":"<code>ActionDelTxn</code>","text":"<p>Delete a transaction from the beancount file.</p> <p>The following keys are available for the delete transaction action:</p> <ul> <li><code>txn</code>: the template of the transaction to insert</li> </ul> <p>A deleting transaction template is an object that contains the following keys:</p> <ul> <li><code>id</code>: the <code>import-id</code> value for ensuring transactions to be deleted. By default, <code>{{ file | as_posix_path }}:{{ lineno }}</code> will be used unless the extractor provides a default value.</li> </ul>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionDelTxn.txn","title":"<code>txn: DeleteTransactionTemplate</code>  <code>instance-attribute</code>","text":"<p>The transaction to delete</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionDelTxn.type","title":"<code>type: typing.Literal[ActionType.del_txn] = pydantic.Field(ActionType.del_txn)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>indicates that this action is to delete a transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionIgnore","title":"<code>ActionIgnore</code>","text":"<p>Ignore the transaction.</p> <p>This prevents the transaction from being added to the beancount file.</p> <p>Sometimes, we are not interested in some transactions, but if we don't process them, you will still see them appear in the \"unprocessed transactions\" section of the report provided by our command line tool. To mark one transaction as processed, you can simply use the <code>ignore</code> action like this:</p> <pre><code>- name: Ignore unused entries\n  match:\n    extractor:\n      equals: \"mercury\"\n    desc:\n      one_of:\n        - Mercury Credit\n        - Mercury Checking xx1234\n  actions:\n    - type: ignore\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.ActionIgnore.type","title":"<code>type: typing.Literal[ActionType.ignore] = pydantic.Field(ActionType.ignore)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>indicates that this action is to ignore the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule","title":"<code>SimpleTxnMatchRule</code>","text":"<p>The raw transactions extracted by the extractor come with many attributes. Here we list only a few from it:</p> <p>The <code>match</code> object should be a dictionary.</p> <p>The key is the transaction attribute to match, and the value is the regular expression of the target pattern to match.</p> <p>All listed attributes need to match so that a transaction will considered matched.</p> <p>Only simple matching logic is possible with the current approach.</p> <p>We will extend the matching rule to support more complex matching logic in the future, such as NOT, AND, OR operators.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.bank_desc","title":"<code>bank_desc: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The bank description of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.category","title":"<code>category: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The category of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.currency","title":"<code>currency: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The currency of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.date","title":"<code>date: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The date of the transaction to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    date: \"2021-01-01\"\n</code></pre> <pre><code>imports:\n- match:\n    date:\n        before: \"2021-01-01\"\n        format: \"%Y-%m-%d\"\n</code></pre> <pre><code>imports:\n- match:\n    date:\n        after: \"2021-01-01\"\n        format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.desc","title":"<code>desc: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The description of the transaction to match.</p> <p>Probably the most common field to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    desc: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        prefix: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        suffix: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        contains: \"DoorDash\"\n</code></pre> <pre><code>imports:\n- match:\n    desc:\n        one_of:\n            - DoorDash\n            - UberEats\n            - Postmate\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.dest_account","title":"<code>dest_account: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The destination account of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.extractor","title":"<code>extractor: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The extractor to match. This will be produced by the Extractor.get_name() method.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.file","title":"<code>file: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The file to match. This will be the file path of the source file.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    file: \"data/transactions.csv\"\n</code></pre> <pre><code>imports:\n- match:\n    file:\n        prefix: \"data/\"\n</code></pre> <pre><code>imports:\n- match:\n    file:\n        suffix: \".csv\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.gl_code","title":"<code>gl_code: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The general ledger code of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.last_four_digits","title":"<code>last_four_digits: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The last four digits of the card of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.name_on_card","title":"<code>name_on_card: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The name on the card of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.note","title":"<code>note: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The note of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.payee","title":"<code>payee: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The payee of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.post_date","title":"<code>post_date: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The post date of the transaction to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    post_date: \"2021-01-01\"\n</code></pre> <pre><code>imports:\n- match:\n    post_date:\n        before: \"2021-01-01\"\n        format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.reference","title":"<code>reference: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The reference of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.source_account","title":"<code>source_account: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The source account of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.status","title":"<code>status: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The status of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.subcategory","title":"<code>subcategory: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The subcategory of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.timezone","title":"<code>timezone: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The timezone of the transaction to match.</p> <p>Examples</p> <pre><code>imports:\n- match:\n    timezone: \"America/Los_Angeles\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.transaction_id","title":"<code>transaction_id: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The transaction id of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.SimpleTxnMatchRule.type","title":"<code>type: StrMatch | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The type of the transaction to match.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate","title":"<code>TransactionTemplate</code>","text":"<p>A transaction transform template.</p> <p>Used to transform the raw transaction into a beancount transaction.</p> <pre><code>txn:\n    date: \"2021-01-01\"\n    flag: \"*\"\n    narration: \"Simple Transaction\"\n    metadata:\n        - name: \"icon\"\n          value: \"\ud83c\udf54\"\n    postings:\n        - account: \"Expenses:Simple\"\n          amount:\n              number: \"{{ amount }}\"\n              currency: \"USD\"\n</code></pre> <p>results in the following beancount transaction:</p> <pre><code>2021-01-01 * \"Simple Transaction\"\n    icon: \ud83c\udf54\n    Expenses:Simple                            100 USD\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.date","title":"<code>date: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the date of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.flag","title":"<code>flag: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the flag of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.id","title":"<code>id: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the import-id for de-duplication</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.links","title":"<code>links: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the links of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.metadata","title":"<code>metadata: list[MetadataItemTemplate] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the metadata of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.narration","title":"<code>narration: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the narration of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.payee","title":"<code>payee: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the payee of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.postings","title":"<code>postings: list[PostingTemplate] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the postings of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TransactionTemplate.tags","title":"<code>tags: list[str] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the tags of the transaction</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DeleteTransactionTemplate","title":"<code>DeleteTransactionTemplate</code>","text":"<p>A transaction delete template.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DeleteTransactionTemplate.id","title":"<code>id: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>the import-id for deleting</p>"},{"location":"configuration/#beancount_importer_rules.data_types.MetadataItemTemplate","title":"<code>MetadataItemTemplate</code>","text":"<p>A metadata list item template.</p> <pre><code>txn:\n    metadata:\n        - name: \"import-id\"\n          value: \"123456\"\n        - name: \"import-src\"\n          value: \"plaid\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.MetadataItemTemplate.name","title":"<code>name: str</code>  <code>instance-attribute</code>","text":"<p>the name of the metadata</p>"},{"location":"configuration/#beancount_importer_rules.data_types.MetadataItemTemplate.value","title":"<code>value: str | bool | int | None</code>  <code>instance-attribute</code>","text":"<p>the value of the metadata</p>"},{"location":"configuration/#beancount_importer_rules.data_types.PostingTemplate","title":"<code>PostingTemplate</code>","text":"<p>A posting transform template.</p> <p>Used to transform the raw transaction into a beancount posting.</p> <pre><code>txn:\n    postings:\n        - account: \"Expenses:Simple\"\n          amount:\n              number: \"{{ amount }}\"\n              currency: \"USD\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.PostingTemplate.account","title":"<code>account: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The account of the posting.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.PostingTemplate.amount","title":"<code>amount: AmountTemplate | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of the posting.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.PostingTemplate.cost","title":"<code>cost: str | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The cost of the posting.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.PostingTemplate.price","title":"<code>price: AmountTemplate | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The price of the posting.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.AmountTemplate","title":"<code>AmountTemplate</code>","text":""},{"location":"configuration/#beancount_importer_rules.data_types.StrPrefixMatch","title":"<code>StrPrefixMatch</code>","text":"<p>To match values with a prefix, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      prefix: \"DoorDash\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.StrPrefixMatch.prefix","title":"<code>prefix: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field start with the string</p>"},{"location":"configuration/#beancount_importer_rules.data_types.StrSuffixMatch","title":"<code>StrSuffixMatch</code>","text":"<p>To match values with a suffix, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      suffix: \"DoorDash\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.StrSuffixMatch.suffix","title":"<code>suffix: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field end with the string</p>"},{"location":"configuration/#beancount_importer_rules.data_types.StrExactMatch","title":"<code>StrExactMatch</code>","text":"<p>To match an exact value, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      equals: \"DoorDash\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.StrExactMatch.equals","title":"<code>equals: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field equal the value</p>"},{"location":"configuration/#beancount_importer_rules.data_types.StrContainsMatch","title":"<code>StrContainsMatch</code>","text":"<p>To match values containing a string, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      contains: \"DoorDash\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.StrContainsMatch.contains","title":"<code>contains: str</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field contain the string</p>"},{"location":"configuration/#beancount_importer_rules.data_types.StrOneOfMatch","title":"<code>StrOneOfMatch</code>","text":"<p>To match values belonging to a list of values, one can do this:</p> <pre><code>imports:\n- match:\n    desc:\n      one_of:\n        - DoorDash\n        - UberEats\n        - Postmate\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.StrOneOfMatch.one_of","title":"<code>one_of: list[str]</code>  <code>instance-attribute</code>","text":"<p>Does the transaction field match one of the values</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateAfterMatch","title":"<code>DateAfterMatch</code>","text":"<p>To match values after a date, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_after: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.DateAfterMatch.date_after","title":"<code>date_after: str</code>  <code>instance-attribute</code>","text":"<p>The date to match after</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateAfterMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateBeforeMatch","title":"<code>DateBeforeMatch</code>","text":"<p>To match values before a date, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_before: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.DateBeforeMatch.date_before","title":"<code>date_before: str</code>  <code>instance-attribute</code>","text":"<p>The date to match before</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateBeforeMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameDayMatch","title":"<code>DateSameDayMatch</code>","text":"<p>To match values with the same day, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_same_day: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameDayMatch.date_same_day","title":"<code>date_same_day: str</code>  <code>instance-attribute</code>","text":"<p>The date to match on the day</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameDayMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameMonthMatch","title":"<code>DateSameMonthMatch</code>","text":"<p>To match values with the same month, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_same_month: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameMonthMatch.date_same_month","title":"<code>date_same_month: str</code>  <code>instance-attribute</code>","text":"<p>The date to match on the month</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameMonthMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameYearMatch","title":"<code>DateSameYearMatch</code>","text":"<p>To match values with the same year, one can do this:</p> <pre><code>imports:\n- match:\n    date:\n      date_same_year: \"2021-01-01\"\n      format: \"%Y-%m-%d\"\n</code></pre>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameYearMatch.date_same_year","title":"<code>date_same_year: str</code>  <code>instance-attribute</code>","text":"<p>The date to match on the year</p>"},{"location":"configuration/#beancount_importer_rules.data_types.DateSameYearMatch.format","title":"<code>format: str</code>  <code>instance-attribute</code>","text":"<p>The format of the date. used to parse the value date and the date to match</p>"},{"location":"configuration/#beancount_importer_rules.data_types.TxnMatchVars","title":"<code>TxnMatchVars</code>","text":"<p>From time to time, you may find yourself writing similar import-matching rules with similar transaction templates. To avoid repeating yourself, you can also write multiple match conditions with their corresponding variables to be used by the template in the same import statement. For example, you can simply do the following two import statements:</p> <pre><code>imports:\n- name: PG&amp;E Gas\n    match:\n    extractor:\n      equals: \"plaid\"\n    desc:\n      prefix: \"PGANDE WEB ONLINE \"\n    actions:\n    - txn:\n        payee: \"{{ payee }}\"\n        narration: \"Paid American Express Blue Cash Everyday\"\n        postings:\n        - account: \"Expenses:Util:Gas:PGE\"\n          amount:\n            number: \"{{ -amount }}\"\n            currency: \"{{ currency | default('USD', true) }}\"\n\n- name: Comcast\n  match:\n    extractor:\n      equals: \"plaid\"\n    desc: \"Comcast\"\n  actions:\n  - txn:\n      payee: \"{{ payee }}\"\n      narration: \"Comcast\"\n      postings:\n      - account: \"Expenses:Util:Internet:Comcast\"\n        amount:\n          number: \"{{ -amount }}\"\n          currency: \"{{ currency | default('USD', true) }}\"\n</code></pre> <p>With match and variables, you can write:</p> <pre><code>imports:\n- name: Household expenses\n  common_cond:\n    extractor:\n      equals: \"plaid\"\n  match:\n  - cond:\n      desc:\n          prefix: \"PGANDE WEB ONLINE \"\n      vars:\n      account: \"Expenses:Util:Gas:PGE\"\n      narration: \"Paid American Express Blue Cash Everyday\"\n  - cond:\n      desc: \"Comcast\"\n      vars:\n      account: \"Expenses:Housing:Util:Internet:Comcast\"\n      narration: \"Comcast\"\n  actions:\n  - txn:\n      payee: \"{{ payee }}\"\n      narration: \"{{ narration }}\"\n      postings:\n      - account: \"{{ account } \"\n          amount:\n            number: \"{{ -amount }}\"\n            currency: \"{{ currency | default('USD', true) }}\"\n</code></pre> <p>The <code>common_cond</code> is the condition to meet for all the matches. Instead of a map, you define the match with the <code>cond</code> field and the corresponding variables with the <code>vars</code> field. Please note that the <code>vars</code> can also be the Jinja2 template and will rendered before feeding into the transaction template. If there are any original variables from the transaction with the same name defined in the <code>vars</code> field, the variables from the <code>vars</code> field always override.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.InputConfig","title":"<code>InputConfig</code>","text":"<p>The input configuration for the import rule.</p>"},{"location":"configuration/#beancount_importer_rules.data_types.OutputConfig","title":"<code>OutputConfig</code>","text":""},{"location":"omit-fields/","title":"Omit fields","text":""},{"location":"omit-fields/#omit-field-in-the-generated-transaction","title":"Omit field in the generated transaction","text":"<p>Sometimes, you may want to omit a particular field in your transactions if the value is unavailable instead of leaving it as a blank string. For example, the <code>payee</code> field sometimes doesn't make sense for some transactions, and the value should not even be present. With a Jinja2 template, it looks like <code>{{ payee }}</code>, but without the <code>payee</code> value provided by the transaction, it will end up with an ugly empty string like this:</p> <pre><code>2024-02-26 * \"\" \"Interest payment\"\n  Assets:Bank:US:WellsFargo:Saving                                          0.06 USD\n  Income:US:BankInterest                                                   -0.06 USD\n</code></pre> <p>To solve the problem, you can use a special variable called <code>omit</code>. The field will be omitted when the rendered value equals the randomly generated <code>omit</code> value. Here's an example:</p> <pre><code>imports:\n  - match:\n      desc: \"...\"\n    actions:\n      - txn:\n          payee: \"{{ payee | default(omit, true) }}\"\n          narration: \"{{ narration }}\"\n          # ...\n</code></pre> <p>As a result, if the <code>payee</code> value is not present, the payee field will be absent from the generated transaction like this:</p> <pre><code>2024-02-26 * \"Interest payment\"\n  Assets:Bank:US:WellsFargo:Saving                                          0.06 USD\n  Income:US:BankInterest                                                   -0.06 USD\n</code></pre>"},{"location":"transaction-ids/","title":"Transaction ids","text":""},{"location":"transaction-ids/#unique-import-id-for-transactions-extracted-from-the-csv-files","title":"Unique import id for transactions extracted from the CSV files","text":"<p>The biggest challenge we face when designing this system is finding a way to deduplicate the imported transactions from CSV. Obviously, we need a way to tell which transactions were already imported into Beancount files so that we don't need to import them again. To make this happen, we introduce the concept of <code>import-id</code>. Each transaction extracted from CSV files should have a unique import ID for us to identify.</p> <p>In this way, we can process the existing Beancount files and find out which transactions have already been imported. We add a metadata item with the key <code>import-id</code> to the transaction.</p> <p>Here's an example:</p> <pre><code>2024-04-15 * \"Circleci\"\n  import-id: \"&lt;unique import id&gt;\"\n  Assets:Bank:US:MyBank                              -30.00 USD\n  Expenses:Engineering:ServiceSubscription            30.00 USD\n</code></pre> <p>The next question will then be: What should be the unique ID for identifying each transaction in the CSV files? If the CSV files come with an ID column that already has a unique value, we can surely use it. However, what if there's no such value in the file? As we observed, most CSV files exported from the bank come with rows ordered by date.</p> <p>The straightforward idea is to use <code>filename + lineno</code> as the id. The Jinja2 template would look like this:</p> <pre><code>{{ file }}:{{ lineno }}\n</code></pre> <p>Then with a transaction from row 123 in the file <code>import-data/mybank/2024.csv</code> should have an import ID like this:</p> <pre><code>import-data/mybank/2024.csv:123\n</code></pre> <p>As most of the bank transactions export CSV files have transactions come in sorted order by date, even if there are new transactions added and we export the CSV file for the same bank again and overwrite the existing file, there will only be new lines added at the bottom of the file.</p> <p>The line number of older transactions from the same CSV file with the same export time range and filter settings should remain the same. The file name and line number serve as a decent default unique identifier for the transactions from CSV files.</p> <p>Although this approach works for most CSV files sorted by date in ascending order, it won't work for files in descending order. For example, CSV files exported from Mercury came in descending order. Obviously, any new transactions added to the export file will change the line number for all previously imported transactions. To overcome the problem, we also provide <code>reverse_lineno</code> attribute in the extracted transaction. It's the <code>lineno - total_row_count</code> value. As you may have noticed, we intentionally made the number negative. It's trying to make it clear that this line (or row) number is in the reversed order, just like Python's negative index for accessing elements from the end.</p> <p>With that, we can define the import ID for Mercury CSV files like this:</p> <pre><code>{{ file }}:{{ reversed_lineno }}\n</code></pre> <p>Since each CSV file may have its own unique best way to reliably identify a transaction,each class of extractor can define its own default import ID template.</p> <pre><code>class YourExtractor(ExtractorBase):\n\n    def get_import_id_template(self) -&gt; str:\n        return \"{{ file }}:{{ reversed_lineno }}\"\n</code></pre>"}]}